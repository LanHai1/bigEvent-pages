<!DOCTYPE html>
<html>

<head lang="en">

    <!-- 

        键盘弹起事件：
            onkeyup:
                因为不管你输入什么，只要输入完了键盘都会弹起，换句话说，键盘弹起了你就是把这个字符输入完了

     -->
    <meta charset="UTF-8">

    <title></title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }
        
        body {
            font-size: 20px;
        }
        
        .box {
            width: 600px;
            height: 40px;
            margin: 200px auto;
            position: relative;
        }
        
        #txt {
            width: 498px;
            height: 38px;
            border: 1px solid #eee;
            font-size: 20px;
        }
        
        #search {
            width: 100px;
            height: 40px;
        }
        
        #keywords {
            position: absolute;
            top: 40px;
            left: 0;
            background-color: rgb(12, 255, 24);
            list-style: none;
            width: 500px;
            ;
        }
        
        li {
            line-height: 24px;
        }
        /* li:hover{
            background-color: red;
        } */
    </style>
</head>

<body>


    <div class="box">
        <!-- 输入的地方 -->
        <div class="top">
            <input type="text" id="txt" /><input type="button" value="search" id="search" />
        </div>

        <!-- 展现联想结果的地方 -->
        <ul id="keywords"></ul>

    </div>
    <script>
        var keywords = ["林利群", "林利群为什么很黑", "林利群的经纪人是周林林吗", "林利群是谁", "广东人", "广东人爱吃", "广东人爱吃福建人", "林丹的生平", "JavaScript",
            "Java", "王思聪", "王健林", "社会王", "隔壁老王", "林绿群", "你打球像蔡徐坤", 'aaa', 'bbb', '王祖蓝', '你打球王祖蓝'
        ];
        let txt = document.getElementById("txt")
        let search = document.getElementById("search")
        let ul = document.getElementById("keywords")

        // 键盘抬起事件
        txt.onkeyup = function() {
            // 先清空上一次联想
            ul.innerHTML = ""

            // 判断是否为空 直接跳出函数
            // indexof("") => 0 条件判断大于-1
            if (this.value.length == 0) {
                return
            }
            // 循环数组
            for (let i = 0; i < keywords.length; i++) {
                // 根据字符串的indexof方法查找数组元素中是否包含了用户输入的字符串
                // 包含则返回的值是改数据在数组元素里面的索引值 所以 > -1
                if (keywords[i].indexOf(this.value) > -1) {
                    // 创建li元素
                    let li = document.createElement("li")
                    li.innerHTML = keywords[i]

                    // 追加到ul中
                    ul.appendChild(li)

                    // li样式
                    liStyle(li)

                    // 历史记录点击记录 => 搜索框赋值
                    li.onclick = function() {
                        txt.value = this.innerHTML

                        // 因为下面设置了失去焦点清空li 失去焦点的执行顺序在点击事件的前面 所以现在再赋值 当前li已经没有任何值了
                        // 解决方案 => 延时器
                    }
                }
            }
        }

        // 鼠标移入联想li
        function liStyle(el) {
            el.onmousemove = function() {
                this.style.backgroundColor = "red"
            }
            el.onmouseout = function() {
                this.style.backgroundColor = ""
            }
        }

        // 点击搜索后保存历史记录
        search.onclick = function() {
            // 未输入则直接跳出函数
            if (txt.value.length == 0) {
                return
            }

            // 获取本地历史记录
            let oldData = localStorage.getItem("data_search")

            // 判断历史记录是否重复
            // 重复则不添加至历史记录
            let new_arr_t = oldData.split(",");
            for (let i = 0; i < new_arr_t.length; i++) {
                if (new_arr_t[i].indexOf(txt.value) > -1) {
                    return
                }
            }

            // 数据处理 => 是否第一次运行网页则无数据
            let newData = oldData ? `${oldData},${txt.value}` : txt.value

            // 保存历史记录指本地
            localStorage.setItem("data_search", newData)

        }

        // 搜索框获取焦点事件 给予历史记录提示
        txt.onfocus = function() {
            // 获取历史记录
            let oldData = localStorage.getItem("data_search")
                // 根据逗号分切字符串 => 数组
                // 倒叙数组 搜索了的排在最前面
            let handlerData = oldData.split(",").reverse()
            for (let i = 0; i < handlerData.length; i++) {
                // 创建li元素
                let li = document.createElement("li")
                li.innerHTML = handlerData[i]

                // 追加到ul中
                ul.appendChild(li)
                liStyle(li)

                // 历史记录点击记录 => 搜索框赋值
                li.onclick = function() {
                    txt.value = this.innerHTML

                    // 因为下面设置了失去焦点清空li 失去焦点的执行顺序在点击事件的前面 所以现在再赋值 当前li已经没有任何值了
                    // 解决方案 => 延时器
                }
            }
        }


        // 搜索框失去焦点事件
        txt.onblur = function() {
            setTimeout(() => {
                ul.innerHTML = ""
            }, 200)
        }
    </script>


</body>

</html>